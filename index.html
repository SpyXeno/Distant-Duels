<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Space Explorer</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@700&display=swap');
        /* --- Basic Setup & Fonts --- */
        * { box-sizing: border-box; -webkit-user-select: none; -moz-user-select: none; -ms-user-select: none; user-select: none; }
        html, body { height: 100%; width: 100%; }
        body { margin: 0; padding: 0; overflow: hidden; background: #000; font-family: 'Orbitron', sans-serif; color: #0ff; text-shadow: 0 0 5px rgba(0,255,255,0.7); }
        canvas { width: 100%; height: 100%; touch-action: none; display: block; }

        /* --- General HUD --- */
        .hud-container { position: absolute; z-index: 10; pointer-events: none; }
        .hud-label { font-size: 10px; text-transform: uppercase; margin-bottom: 2px; color: rgba(0, 255, 255, 0.8); }
        .value { font-weight: bold; font-size: 16px; min-width: 40px; display: inline-block; }
        .bar-container { height: 10px; background-color: rgba(50, 50, 50, 0.7); border-radius: 3px; overflow: hidden; border: 1px solid rgba(0, 255, 255, 0.3); margin-top: 1px; }
        .bar { height: 100%; width: 0%; transition: width 0.2s ease; border-radius: 2px; }
        .player-health { background-color: #00ff00; } .enemy-health { background-color: #ff3333; } .player-shield { background-color: #00aaff; } .enemy-shield { background-color: #ff8800; } .heat { background-color: #ffff00; }

        /* --- Player HUD --- */
        #playerHud { bottom: 20px; left: 20px; }
        .mobile #playerHud { top: 10px; bottom: auto; } /* Move on mobile */
        #playerHud > div { margin-bottom: 8px; }
        #playerShieldContainer .bar-container { width: 180px; height: 8px; }
        #playerHealthContainer .bar-container { width: 200px; height: 12px; }
        #heatBarContainer .bar-container { width: 100px; height: 8px; }
        #heatBarContainer .hud-label { margin-top: 3px; margin-bottom: 0; }

        /* --- Enemy HUD --- */
        #enemyHudTop { top: 15px; left: 50%; transform: translateX(-50%); text-align: center; }
        .mobile #enemyHudTop { top: 85px; } /* Lower on mobile portrait */
        #enemyName { font-size: 14px; margin-bottom: 3px; color: #ff3333; text-shadow: 0 0 5px rgba(255, 50, 50, 0.8); }
        #enemyShieldContainer { margin-top: 4px; } #enemyShieldContainer .bar-container { width: 130px; height: 8px; margin: 0 auto; }
        #enemyHealthContainer { margin-top: 2px; } #enemyHealthContainer .bar-container { width: 150px; margin: 0 auto; }

        /* --- Target Reticle --- */
        #target { position: absolute; top: 50%; left: 50%; width: 20px; height: 20px; transform: translate(-50%, -50%); pointer-events: none; }
        #target::before, #target::after { content: ''; position: absolute; background-color: rgba(0,255,255,0.7); }
        #target::before { width: 20px; height: 2px; top: 9px; left: 0; } #target::after { width: 2px; height: 20px; top: 0; left: 9px; }
        body.lock-on-active #target { display: none; }

        /* --- Controls Button & Modal --- */
        #controlsButton { position: absolute; top: 15px; right: 15px; z-index: 20; padding: 5px 10px; font-size: 12px; background-color: rgba(0, 100, 100, 0.6); border: 1px solid rgba(0, 255, 255, 0.7); color: #0ff; cursor: pointer; border-radius: 4px; font-family: 'Orbitron', sans-serif; text-shadow: 0 0 3px rgba(0,255,255,0.7); }
        .mobile #controlsButton { padding: 3px 6px; font-size: 10px; }
        #controlsButton:hover { background-color: rgba(0, 150, 150, 0.8); }
        #controlsModal { display: none; position: absolute; top: 55px; right: 15px; width: 200px; background-color: rgba(0, 20, 30, 0.9); border: 1px solid rgba(0, 255, 255, 0.7); border-radius: 5px; padding: 15px; z-index: 100; color: #0ff; font-size: 13px; line-height: 1.6; pointer-events: auto; }
        #controlsModal h4 { margin-top: 0; margin-bottom: 10px; text-align: center; border-bottom: 1px solid rgba(0, 255, 255, 0.3); padding-bottom: 5px; }
        #controlsModal p { margin: 3px 0; }
        #closeControlsButton { position: absolute; top: 5px; right: 8px; background: none; border: none; font-size: 18px; color: #0aa; cursor: pointer; }
        #closeControlsButton:hover { color: #0ff; }

        /* --- Virtual Joystick (Right Stick Only) --- */
        .joystick-base { position: absolute; width: 120px; height: 120px; background-color: rgba(100, 100, 100, 0.3); border-radius: 50%; border: 2px solid rgba(0, 255, 255, 0.4); bottom: 30px; z-index: 50; display: none; pointer-events: auto; }
        .joystick-knob { position: absolute; width: 50px; height: 50px; background-color: rgba(0, 200, 200, 0.5); border-radius: 50%; border: 1px solid rgba(0, 255, 255, 0.7); top: 50%; left: 50%; transform: translate(-50%, -50%); pointer-events: none; }
        .mobile .joystick-base { display: block; }
        #rightStickBase { right: 30px; }

        /* --- Left Side Mobile Buttons --- */
        .mobile-button { position: absolute; width: 80px; height: 45px; background-color: rgba(0, 150, 255, 0.4); border: 2px solid rgba(100, 200, 255, 0.6); border-radius: 8px; left: 25px; z-index: 50; display: none; pointer-events: auto; color: rgba(150, 220, 255, 0.9); font-size: 13px; font-weight: bold; text-align: center; line-height: 41px; text-shadow: 0 0 5px blue; }
        .mobile .mobile-button { display: block; }
        .mobile-button:active { background-color: rgba(50, 180, 255, 0.6); }
        #boostButtonMobile { bottom: 125px; background-color: rgba(255, 150, 0, 0.4); border-color: rgba(255, 200, 100, 0.6); color: rgba(255, 200, 150, 0.9); }
        #thrustButtonMobile { bottom: 75px; }
        #autoThrustButtonMobile { bottom: 25px; background-color: rgba(100, 100, 100, 0.4); border-color: rgba(150, 150, 150, 0.6); color: rgba(200, 200, 200, 0.9); }
        #autoThrustButtonMobile.auto-thrust-active { background-color: rgba(0, 255, 0, 0.5); border-color: rgba(100, 255, 100, 0.7); color: rgba(200, 255, 200, 0.9); }

        /* --- Action Buttons (Fire/Lock - Mobile) --- */
        .action-button { position: absolute; z-index: 50; display: none; pointer-events: auto; }
        .mobile .action-button { display: block; }
        #fireButtonLeft { width: 70px; height: 70px; background-color: rgba(255, 0, 0, 0.4); border: 2px solid rgba(255, 100, 100, 0.6); border-radius: 50%; bottom: 75px; left: 115px; color: rgba(255, 150, 150, 0.9); font-size: 40px; line-height: 66px; text-align: center; text-shadow: 0 0 5px red; }
        #fireButtonLeft:active { background-color: rgba(255, 50, 50, 0.6); }
        #lockOnButtonMobile { width: 80px; height: 45px; background-color: rgba(150, 150, 150, 0.4); border: 2px solid rgba(200, 200, 200, 0.6); border-radius: 8px; bottom: 25px; left: 115px; color: rgba(220, 220, 220, 0.9); font-size: 11px; font-weight: bold; line-height: 41px; text-align: center; text-shadow: none; }
        #lockOnButtonMobile:active { background-color: rgba(180, 180, 180, 0.6); }
        #lockOnButtonMobile.lock-on-active { background-color: rgba(0, 200, 255, 0.6); border-color: rgba(100, 220, 255, 0.8); color: #fff; }

        /* --- Game Over --- */
        #gameOverMessage { position: absolute; top: 45%; left: 50%; transform: translate(-50%, -50%); color: #ff0000; font-size: 48px; font-weight: bold; text-align: center; text-shadow: 2px 2px 4px #000000; pointer-events: none; display: none; z-index: 100; }
        #restartButton { position: absolute; top: 60%; left: 50%; transform: translate(-50%, -50%); padding: 10px 20px; font-size: 24px; font-family: 'Orbitron', sans-serif; cursor: pointer; background-color: #335599; color: white; border: none; border-radius: 5px; display: none; z-index: 100; }
        @media (max-width: 600px), (max-height: 500px) { #gameOverMessage { font-size: 28px; width: 90%; } #restartButton { font-size: 18px; padding: 8px 16px; top: 65%; } }

    </style>
</head>
<body>
    <!-- UI Elements -->
    <div id="playerHud" class="hud-container"> <div id="playerShieldContainer"> <div class="hud-label">Shield</div> <div class="bar-container"> <div id="hud-player-shield-bar" class="bar player-shield" style="width: 100%"></div> </div> </div> <div id="playerHealthContainer"> <div class="hud-label">Health</div> <div class="bar-container"> <div id="hud-player-health-bar" class="bar player-health" style="width: 100%"></div> </div> </div> <div id="heatBarContainer"> <div class="bar-container"> <div id="hud-weapon-heat-bar" class="bar heat" style="width: 0%"></div> </div> <div class="hud-label">Heat (<span id="hud-weapon-heat-value">0</span>%)</div> </div> </div>
    <div id="enemyHudTop" class="hud-container"> <div id="enemyName">---</div> <div id="enemyShieldContainer"> <div class="bar-container"> <div id="hud-enemy-shield-bar" class="bar enemy-shield" style="width: 100%"></div> </div> </div> <div id="enemyHealthContainer"> <div class="bar-container"> <div id="hud-enemy-health-bar" class="bar enemy-health" style="width: 100%"></div> </div> </div> </div>
    <div id="target"></div>
    <button id="controlsButton">Controls</button>
    <div id="controlsModal"> <button id="closeControlsButton">&times;</button> <h4>CONTROLS</h4> <p><b>WASD:</b> Move / Turn</p> <p><b>Arrows:</b> Pitch / Roll</p> <p><b>SPACE:</b> Fire Weapon</p> <p><b>L SHIFT:</b> Boost</p> <p><b>S Key:</b> Reverse Thrust</p> <p><b>E Key:</b> Toggle Lock-On</p> <p><b>Mouse:</b> Orbit Camera</p> <p><b>R:</b> Reset Camera</p> <p><b>-/+:</b> Cam Smoothing</p> <p><b>P:</b> Pause</p> </div>
    <!-- Enemy Indicator Div REMOVED -->
    <div id="gameOverMessage"></div> <button id="restartButton">Restart Game</button>
    <!-- Mobile Controls -->
    <div id="rightStickBase" class="joystick-base"> <div id="rightStickKnob" class="joystick-knob"></div> </div>
    <button id="boostButtonMobile" class="mobile-button">BOOST</button>
    <button id="thrustButtonMobile" class="mobile-button">THRUST</button>
    <button id="autoThrustButtonMobile" class="mobile-button">AUTO</button>
    <div id="fireButtonLeft" class="action-button">&#x25CE;</div>
    <button id="lockOnButtonMobile" class="action-button">LOCK</button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r134/three.min.js"></script>
    <script>
        // --- Constants ---
        const ACCELERATION = 0.002; const MAX_PLAYER_SPEED = 0.8; const DAMPING = 0.97; const BOOST_MULTIPLIER = 2; const ROLL_SPEED = 0.03; const PITCH_SPEED = 0.02; const YAW_SPEED = 0.02;
        const MOBILE_ROTATION_MULTIPLIER = 0.8; const MOBILE_ROLL_MULTIPLIER = 1.4; const MOBILE_ACCEL_MULTIPLIER = 1.0;
        const CAMERA_BASE_DISTANCE = 2.5; const CAMERA_BASE_HEIGHT = 0.8; const CAMERA_MIN_DISTANCE = 1.5; const CAMERA_MAX_DISTANCE = 10.0; const CAMERA_DEFAULT_FOLLOW_SPEED = 0.1; const CAMERA_LOOK_AHEAD_FACTOR = 10;
        const CAMERA_UP_SMOOTH_SPEED = 0.05; const CAMERA_LOCK_ON_SPEED = 0.02;
        const PORTRAIT_FOV = 75; const PORTRAIT_CAM_DISTANCE_FACTOR = 1.3;
        const WEAPON_FIRE_RATE_MS = 250; const WEAPON_MAX_HEAT = 100; const WEAPON_HEAT_PER_SHOT = 10; const WEAPON_COOLING_RATE_PER_SEC = 15; const PROJECTILE_SPEED = 0.5; const PROJECTILE_LIFESPAN_MS = 5000; const PROJECTILE_ENEMY_LIFESPAN_MS = 3000; const PROJECTILE_RADIUS = 0.05; const PROJECTILE_DAMAGE = 10; const ENEMY_PROJECTILE_SPEED = 0.4; const ENEMY_PROJECTILE_DAMAGE = 10;
        const TRAIL_MAX_LENGTH = 12; const TRAIL_UPDATE_INTERVAL_FRAMES = 5; const TRAIL_MIN_DISTANCE = 0.05; const TRAIL_TUBE_RADIUS = 0.01; const PLAYER_TRAIL_FADE_DURATION_MS = 1000; const ENEMY_TRAIL_FADE_DURATION_MS = 3000; /* Longer */ const TRAIL_OPACITY = 0.7; const PLAYER_TRAIL_COLOR = 0x00ffff; const ENEMY_TRAIL_COLOR = 0xff3333;
        const ENEMY_MAX_SPEED = 0.6; const ENEMY_BOOST_SPEED = ENEMY_MAX_SPEED * 1.4; const ENEMY_PATROL_SPEED = ENEMY_MAX_SPEED * 0.4; const ENEMY_DAMPING = 0.98; const ENEMY_OPTIMAL_DISTANCE = 10; const ENEMY_FIRE_RATE_MS = 1000; const ENEMY_AVOIDANCE_DISTANCE = 15; const ENEMY_AVOIDANCE_STRENGTH = 0.003; const ENEMY_MAX_RANGE = 25; const ENEMY_MAX_CENTER_DISTANCE = 150; const ENEMY_LEAD_FACTOR = 0.6; const ENEMY_FIRING_ANGLE_THRESHOLD = 0.7;
        const PATROL_DETECTION_RANGE = 40; const EVADE_JITTER_STRENGTH = 0.002; const EVADE_ROLL_RATE = 0.05; const EVADE_BOOST_CHANCE = 0.05;
        const PLAYER_START_HEALTH = 200; const ENEMY_START_HEALTH = 200;
        const MAX_SHIELD = 100; const SHIELD_RECHARGE_DELAY_MS = 5000; const SHIELD_RECHARGE_RATE_PER_SEC = 15;
        const PLANET_COUNT = 4; const PLANET_MIN_DISTANCE = 35; const PLANET_SPACING = 25; const PLANET_SIZE_MULTIPLIER = 4.0; const SUN_RADIUS = 25; const SUN_GLOW_RADIUS = SUN_RADIUS * 1.08;
        const SUN_DAMAGE_START_DISTANCE = SUN_RADIUS + 10; const SUN_INSTA_DEATH_DISTANCE = SUN_RADIUS + 2; const SUN_DAMAGE_PER_SECOND = 15;
        const STAR_COUNT_MIN = 3000; const STAR_COUNT_MAX = 5000; const STAR_SIZE = 0.5;
        const STICK_RADIUS = 60; const STICK_DEADZONE = 0.15;
        // const INDICATOR_CIRCLE_RADIUS = 150; // Removed

        // --- Scene Variables ---
        let scene, camera, renderer; let sun, sunGlow; let stars; const planets = [];
        // --- Player Ship Variables ---
        let ship; const shipVelocity = new THREE.Vector3(0, 0, 0); const shipForwardDir = new THREE.Vector3(0, 0, 1); const keysPressed = {}; let playerHealth = PLAYER_START_HEALTH; let playerShield = MAX_SHIELD; let playerShieldRechargeTimer = 0;
        // --- Camera Variables ---
        let cameraDistance = CAMERA_BASE_DISTANCE; let cameraHeight = CAMERA_BASE_HEIGHT; const cameraOffset = new THREE.Vector3(0, CAMERA_BASE_HEIGHT, -CAMERA_BASE_DISTANCE); const cameraSmoothPosition = new THREE.Vector3(); const cameraTargetPosition = new THREE.Vector3(); const cameraLookAtTarget = new THREE.Vector3(); const smoothLookAtTarget = new THREE.Vector3(); let cameraFollowSpeed = CAMERA_DEFAULT_FOLLOW_SPEED; let defaultFov = 60; let defaultCamDistance = CAMERA_BASE_DISTANCE; const cameraSmoothUp = new THREE.Vector3(0, 1, 0); let isCameraLockedOn = false;
        // --- Weapon System Variables ---
        const projectiles = []; let lastFireTime = 0; let weaponHeat = 0;
        // --- Player Trail Effect Variables ---
        const trailPoints = []; const trailSegments = []; let playerFrameCount = 0; const lastTrailPosition = new THREE.Vector3();
        // --- Enemy Trail Effect Variables ---
        const enemyTrailPoints = []; const enemyTrailSegments = []; let enemyFrameCount = 0; const lastEnemyTrailPosition = new THREE.Vector3();
        // --- Enemy Ship Variables ---
        let enemyShip; const enemyVelocity = new THREE.Vector3(); let enemyHealth = ENEMY_START_HEALTH; let enemyShield = MAX_SHIELD; let enemyShieldRechargeTimer = 0; let enemyLastFireTime = 0; const enemyProjectiles = []; let enemyState = 'patrol'; let enemyStateTimer = 0; const enemyManeuverTarget = new THREE.Vector3(); const enemyPatrolTarget = new THREE.Vector3(); let currentEnemyName = "Pirate"; let enemyBoostTimer = 0;
        // --- Game State ---
        let isPaused = false; let isGameOver = false; let lastTimestamp = 0; let isMobile = false; let isAutoThrusting = false;
        // --- HUD Element References ---
        let hudPlayerHealthValueEl, hudPlayerHealthBarEl, hudPlayerShieldBarEl, hudEnemyHealthValueEl, hudEnemyHealthBarEl, hudEnemyShieldBarEl, hudWeaponHeatValueEl, hudWeaponHeatBarEl, gameOverMessageEl, restartButtonEl, controlsButtonEl, controlsModalEl, closeControlsButtonEl, enemyNameEl, /* enemyIndicatorEl REMOVED */ rightStickBaseEl, rightStickKnobEl, fireButtonLeftEl, boostButtonMobileEl, thrustButtonMobileEl, autoThrustButtonMobileEl, lockOnButtonMobileEl;
        // --- Waypoint Indicator ---
        let waypointIndicatorMesh = null;
        // --- Mobile Control State ---
        const rightStick = { active: false, touchId: null, startX: 0, startY: 0, centerX: 0, centerY: 0, deltaX: 0, deltaY: 0 };
        // --- Reusable Temp Objects ---
        const _tempVec1 = new THREE.Vector3(); const _tempVec2 = new THREE.Vector3(); const _tempVec3 = new THREE.Vector3(); const _quaternion = new THREE.Quaternion(); const _forward = new THREE.Vector3(); const _color = new THREE.Color(); const _projScreenPos = new THREE.Vector3(); const _cameraLookDir = new THREE.Vector3(); const _indicatorDir = new THREE.Vector3(); const _playerVel = new THREE.Vector3(); const _up = new THREE.Vector3(0, 1, 0); const _enemyPosCameraSpace = new THREE.Vector3(); const _shipUp = new THREE.Vector3();

        // --- Simplified Planet Definitions ---
        const planetTypes = [ { name: 'Cold', prob: 0.23, colors: [0x87CEEB, 0xADD8E6, 0xF0F8FF, 0xB0E0E6, 0xE6F0FA], bump: 0.1, atmosphereChance: 0.6, category: 'Rocky', size: 1 }, { name: 'Hot', prob: 0.23, colors: [0xFF4500, 0xFFA500, 0xFF6347, 0xFF8C00, 0xDC143C], bump: 0.05, atmosphereChance: 0.4, category: 'Rocky', size: 1 }, { name: 'Barren', prob: 0.23, colors: [0x808080, 0xA9A9A9, 0xD3D3D3, 0xB0B0B0, 0x696969], bump: 0.15, atmosphereChance: 0.2, category: 'Rocky', size: 1 }, { name: 'Ringed', prob: 0.08, colors: [0xDAA520, 0xFFD700, 0xF4A460, 0xFFEC8B, 0xCD950C], bump: 0.08, atmosphereChance: 0.7, category: 'Gassy', size: 1 }, { name: 'Gas Giant', prob: 0.17, colors: [0xFF69B4, 0xFFD700, 0x00FF00, 0xFF00FF, 0x00FFFF], bump: 0.1, atmosphereChance: 1.0, category: 'Gassy', size: 2.5 }, { name: 'Magma', prob: 0.06, colors: [0x8B0000, 0xFF4500, 0xFFA500, 0xCD5C5C, 0xFF6A6A], bump: 0.15, atmosphereChance: 0.3, category: 'Rocky', size: 1 } ];
        function getRandomPlanetType() { const rand = Math.random(); let cumulativeProb = 0; for (const type of planetTypes) { cumulativeProb += type.prob; if (rand <= cumulativeProb) return type; } return planetTypes[planetTypes.length - 1]; }

        // --- Enemy Name Generation ---
        const namePrefixes = ["Void", "Grim", "Star", "Iron", "Shadow", "Cosmic", "Mad", "Red", "Black", "Cyber"]; const nameSuffixes = ["Reaver", "Skull", "Blade", "Striker", "Specter", "Jackal", "Marauder", "Ronin", "Viper", "Claw"];
        function generateEnemyName() { const prefix = namePrefixes[Math.floor(Math.random() * namePrefixes.length)]; const suffix = nameSuffixes[Math.floor(Math.random() * nameSuffixes.length)]; return `${prefix} ${suffix}`; }

        // Initialize the game
        function init() { detectMobile(); setupScene(); setupLighting(); cacheHUDElements(); setupMobileControls(); adjustCameraForOrientation(); createStarryBackground(); createStarSystem(); createShip(); createEnemyShip(); setupEventListeners(); initializeTrailEffect(); initializeEnemyTrailEffect(); lastTimestamp = performance.now(); animate(); }

        // --- Mobile Detection ---
        function detectMobile() { isMobile = navigator.maxTouchPoints > 0 || 'ontouchstart' in window; if (isMobile) { document.body.classList.add('mobile'); } }

        // --- Adjust Camera for Orientation ---
        function adjustCameraForOrientation() { if (!camera) return; const isPortrait = isMobile && window.innerHeight > window.innerWidth; if (isPortrait) { camera.fov = PORTRAIT_FOV; cameraOffset.z = -defaultCamDistance * PORTRAIT_CAM_DISTANCE_FACTOR; } else { camera.fov = defaultFov; cameraOffset.z = -defaultCamDistance; } camera.updateProjectionMatrix(); cameraDistance = -cameraOffset.z; }

        // Cache HUD elements
        function cacheHUDElements() { const d=document; hudPlayerHealthValueEl=d.getElementById('hud-player-health-value'); hudPlayerHealthBarEl=d.getElementById('hud-player-health-bar'); hudPlayerShieldBarEl=d.getElementById('hud-player-shield-bar'); hudEnemyHealthValueEl=d.getElementById('hud-enemy-health-value'); hudEnemyHealthBarEl=d.getElementById('hud-enemy-health-bar'); hudEnemyShieldBarEl=d.getElementById('hud-enemy-shield-bar'); hudWeaponHeatValueEl=d.getElementById('hud-weapon-heat-value'); hudWeaponHeatBarEl=d.getElementById('hud-weapon-heat-bar'); gameOverMessageEl=d.getElementById('gameOverMessage'); restartButtonEl=d.getElementById('restartButton'); controlsButtonEl=d.getElementById('controlsButton'); controlsModalEl=d.getElementById('controlsModal'); closeControlsButtonEl=d.getElementById('closeControlsButton'); enemyNameEl=d.getElementById('enemyName'); /* enemyIndicatorEl removed */ rightStickBaseEl = d.getElementById('rightStickBase'); rightStickKnobEl = d.getElementById('rightStickKnob'); fireButtonLeftEl = d.getElementById('fireButtonLeft'); boostButtonMobileEl = d.getElementById('boostButtonMobile'); thrustButtonMobileEl = d.getElementById('thrustButtonMobile'); autoThrustButtonMobileEl = d.getElementById('autoThrustButtonMobile'); lockOnButtonMobileEl = d.getElementById('lockOnButtonMobile'); }

        // Setup Three.js scene
        function setupScene() { scene = new THREE.Scene(); defaultFov = 60; defaultCamDistance = CAMERA_BASE_DISTANCE; camera = new THREE.PerspectiveCamera(defaultFov, window.innerWidth / window.innerHeight, 0.1, 1500); renderer = new THREE.WebGLRenderer({ antialias: true }); renderer.setSize(window.innerWidth, window.innerHeight); renderer.setClearColor(0x000000); document.body.appendChild(renderer.domElement); cameraSmoothPosition.set(0, 10, 15); camera.position.copy(cameraSmoothPosition); camera.lookAt(0, 0, 0); cameraSmoothUp.copy(camera.up); smoothLookAtTarget.copy(camera.position).add(new THREE.Vector3(0,0,-10).applyQuaternion(camera.quaternion));
            // Waypoint Indicator Mesh
            const waypointGeo = new THREE.ConeGeometry(0.03, 0.1, 6); waypointGeo.translate(0, 0.05, 0); waypointGeo.rotateX(Math.PI / 2); /* Point tip along +Z */ const waypointMat = new THREE.MeshBasicMaterial({ color: ENEMY_TRAIL_COLOR, transparent: true, opacity: 0.85, depthTest: false, side: THREE.DoubleSide }); waypointIndicatorMesh = new THREE.Mesh(waypointGeo, waypointMat); waypointIndicatorMesh.position.set(0, 0.45, -1.5); camera.add(waypointIndicatorMesh); waypointIndicatorMesh.visible = false; }

        // Setup scene lighting
        function setupLighting() { const ambientLight = new THREE.AmbientLight(0x404040); scene.add(ambientLight); }

        // Create stars for background
        function createStarryBackground() { if (stars) { scene.remove(stars); if(stars.geometry) stars.geometry.dispose(); if(stars.material) stars.material.dispose(); } const starGeometry = new THREE.BufferGeometry(); const starCount = Math.floor(Math.random() * (STAR_COUNT_MAX - STAR_COUNT_MIN + 1)) + STAR_COUNT_MIN; const positions = new Float32Array(starCount * 3); const colors = new Float32Array(starCount * 3); const hues = [240, 300, 0, 120, 180, 270, 60]; const nebulaHue = hues[Math.floor(Math.random() * hues.length)]; const baseNebulaColor = new THREE.Color(`hsl(${nebulaHue}, 20%, 15%)`); scene.background = baseNebulaColor; const starColor = new THREE.Color(); for (let i = 0; i < starCount; i++) { const i3 = i * 3; positions[i3] = (Math.random() - 0.5) * 1200; positions[i3 + 1] = (Math.random() - 0.5) * 1200; positions[i3 + 2] = (Math.random() - 0.5) * 1200; let lightness = Math.random() * 0.4 + 0.4; if (Math.random() < 0.1) { starColor.setHex([0xFF4500, 0x87CEEB, 0xFFA500][Math.floor(Math.random() * 3)]); } else { starColor.setHex(0xFFFFFF); } starColor.multiplyScalar(lightness); colors[i3] = starColor.r; colors[i3 + 1] = starColor.g; colors[i3 + 2] = starColor.b; } starGeometry.setAttribute('position', new THREE.BufferAttribute(positions, 3)); starGeometry.setAttribute('color', new THREE.BufferAttribute(colors, 3)); const starMaterial = new THREE.PointsMaterial({ size: STAR_SIZE, sizeAttenuation: true, transparent: true, opacity: 0.9, vertexColors: true, depthWrite: false }); stars = new THREE.Points(starGeometry, starMaterial); scene.add(stars); }

        // Create player ship (Spawns near furthest planet)
        function createShip() { ship = new THREE.Group(); const shipColor=0x3366ff; const bodyColor=0x1a4da6; const wingColor=shipColor; const cockpitColor=0x87CEEB; const engineColor=0x444444; const thrusterColor=PLAYER_TRAIL_COLOR; const weaponColor=0xff3333; const coneGeometry=new THREE.ConeGeometry(0.5,2,4); const boxGeometry=new THREE.BoxGeometry(0.7,0.4,1); const wingGeometry=new THREE.BoxGeometry(2,0.1,0.7); const cockpitGeometry=new THREE.SphereGeometry(0.25,16,16,0,Math.PI*2,0,Math.PI/2); const engineGeometry=new THREE.CylinderGeometry(0.3,0.4,0.5,16); const thrusterGeometry=new THREE.ConeGeometry(0.2,0.5,16); const smallThrusterGeometry=new THREE.ConeGeometry(0.1,0.3,16); const weaponGeometry=new THREE.BoxGeometry(0.1,0.1,0.3); const mainMaterial=new THREE.MeshPhongMaterial({color:shipColor}); const bodyMaterial=new THREE.MeshPhongMaterial({color:bodyColor}); const wingMaterial=new THREE.MeshPhongMaterial({color:wingColor}); const cockpitMaterial=new THREE.MeshPhongMaterial({color:cockpitColor,transparent:true,opacity:0.7,shininess:100}); const engineMaterial=new THREE.MeshPhongMaterial({color:engineColor}); const thrusterMaterial=new THREE.MeshBasicMaterial({color:thrusterColor,transparent:true,opacity:0.7,side:THREE.DoubleSide}); const weaponMaterial=new THREE.MeshPhongMaterial({color:weaponColor}); const cone=new THREE.Mesh(coneGeometry,mainMaterial); cone.rotation.x=Math.PI/2; cone.position.z=0.8; ship.add(cone); const body=new THREE.Mesh(boxGeometry,bodyMaterial); ship.add(body); const leftWing=new THREE.Mesh(wingGeometry,wingMaterial); leftWing.position.x=-0.7; ship.add(leftWing); const rightWing=new THREE.Mesh(wingGeometry,wingMaterial); rightWing.position.x=0.7; ship.add(rightWing); const cockpit=new THREE.Mesh(cockpitGeometry,cockpitMaterial); cockpit.rotation.x=Math.PI; cockpit.position.set(0,0.2,0.2); ship.add(cockpit); const engine=new THREE.Mesh(engineGeometry,engineMaterial); engine.rotation.x=Math.PI/2; engine.position.set(0,0, -0.7); ship.add(engine); const mainThruster=new THREE.Mesh(thrusterGeometry,thrusterMaterial.clone()); mainThruster.rotation.x=-Math.PI/2; mainThruster.position.set(0,0,-1); mainThruster.userData.isThruster=true; ship.add(mainThruster); const leftThruster=new THREE.Mesh(smallThrusterGeometry,thrusterMaterial.clone()); leftThruster.rotation.x=-Math.PI/2; leftThruster.position.set(-0.3,0,-0.8); leftThruster.userData.isThruster=true; ship.add(leftThruster); const rightThruster=new THREE.Mesh(smallThrusterGeometry,thrusterMaterial.clone()); rightThruster.rotation.x=-Math.PI/2; rightThruster.position.set(0.3,0,-0.8); rightThruster.userData.isThruster=true; ship.add(rightThruster); const mainThrusterLight=new THREE.PointLight(thrusterColor,2,3); mainThrusterLight.position.set(0,0,-1); mainThrusterLight.userData.isThrusterLight=true; ship.add(mainThrusterLight); const leftThrusterLight=new THREE.PointLight(thrusterColor,1,2); leftThrusterLight.position.set(-0.3,0,-0.9); leftThrusterLight.userData.isThrusterLight=true; ship.add(leftThrusterLight); const rightThrusterLight=new THREE.PointLight(thrusterColor,1,2); rightThrusterLight.position.set(0.3,0,-0.9); rightThrusterLight.userData.isThrusterLight=true; ship.add(rightThrusterLight); const leftWeapon=new THREE.Mesh(weaponGeometry,weaponMaterial); leftWeapon.position.set(-0.5,0,0.6); ship.add(leftWeapon); const rightWeapon=new THREE.Mesh(weaponGeometry,weaponMaterial); rightWeapon.position.set(0.5,0,0.6); ship.add(rightWeapon); ship.scale.set(0.2,0.2,0.2); ship.rotation.order='YXZ';
            let spawnPlanet = null; if (planets.length > 0) { spawnPlanet = planets[planets.length - 1]; } if (spawnPlanet) { const planetRadius = spawnPlanet.userData.radius || 5; const spawnDistance = planetRadius + 5 + Math.random() * 5; const spawnAngle = Math.random() * Math.PI * 2; const spawnHeight = (Math.random() - 0.5) * 4; _tempVec1.set( Math.cos(spawnAngle) * spawnDistance, spawnHeight, Math.sin(spawnAngle) * spawnDistance ); ship.position.copy(spawnPlanet.position).add(_tempVec1); ship.lookAt(spawnPlanet.position); ship.rotateY(Math.PI); } else { ship.position.set(0, 5, 15); } scene.add(ship); lastTrailPosition.copy(ship.position); playerShield = MAX_SHIELD; playerHealth = PLAYER_START_HEALTH; playerShieldRechargeTimer = 0; }

        // Create the sun
        function createSun() { const sunGeometry = new THREE.SphereGeometry(SUN_RADIUS, 32, 32); const sunCanvas = document.createElement('canvas'); sunCanvas.width = 512; sunCanvas.height = 512; const ctx = sunCanvas.getContext('2d'); const center = sunCanvas.width / 2; const gradient = ctx.createRadialGradient(center, center, 0, center, center, center); gradient.addColorStop(0, '#ffff00'); gradient.addColorStop(0.5, '#ffaa00'); gradient.addColorStop(1, '#ff7700'); ctx.fillStyle = gradient; ctx.fillRect(0, 0, sunCanvas.width, sunCanvas.height); ctx.globalCompositeOperation = 'overlay'; for (let i = 0; i < 30; i++) {const x=Math.random()*sunCanvas.width; const y=Math.random()*sunCanvas.height; const size=20+Math.random()*80; const flareGradient=ctx.createRadialGradient(x,y,0,x,y,size); flareGradient.addColorStop(0,'rgba(255, 255, 200, 0.8)'); flareGradient.addColorStop(1,'rgba(255, 150, 50, 0)'); ctx.fillStyle=flareGradient; ctx.beginPath(); ctx.arc(x,y,size,0,Math.PI*2); ctx.fill();} ctx.globalCompositeOperation = 'multiply'; for (let i = 0; i < 15; i++) {const x=Math.random()*sunCanvas.width; const y=Math.random()*sunCanvas.height; const size=5+Math.random()*15; ctx.fillStyle='rgba(50, 0, 0, 0.5)'; ctx.beginPath(); ctx.arc(x,y,size,0,Math.PI*2); ctx.fill();} ctx.globalCompositeOperation = 'overlay'; const cellSize = 8; for (let x = 0; x < sunCanvas.width; x += cellSize) for (let y = 0; y < sunCanvas.height; y += cellSize) { if (Math.random() > 0.5) { const brightness = 0.85 + Math.random() * 0.3; ctx.fillStyle = `rgba(255, 255, 200, ${brightness * 0.2})`; ctx.fillRect(x, y, cellSize, cellSize); } } const sunTexture = new THREE.CanvasTexture(sunCanvas); const sunMaterial = new THREE.MeshBasicMaterial({ map: sunTexture }); sun = new THREE.Mesh(sunGeometry, sunMaterial); scene.add(sun); const glowGeometry = new THREE.SphereGeometry(SUN_GLOW_RADIUS, 32, 32); const glowMaterial = new THREE.ShaderMaterial({ uniforms: { "c": { value: 0.2 }, "p": { value: 2.0 }, glowColor: { value: new THREE.Color(0xffaa00) }, viewVector: { value: new THREE.Vector3() } }, vertexShader: ` uniform vec3 viewVector; uniform float c; uniform float p; varying float intensity; void main() { vec3 vNormal = normalize( normalMatrix * normal ); vec3 vView = normalize( viewVector ); intensity = pow( max(c - dot( vNormal, vView ), 0.0), p ); gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 ); }`, fragmentShader: ` uniform vec3 glowColor; varying float intensity; void main() { vec3 glow = glowColor * intensity; gl_FragColor = vec4( glow, intensity * intensity ); }`, side: THREE.BackSide, blending: THREE.AdditiveBlending, transparent: true, depthWrite: false }); sunGlow = new THREE.Mesh(glowGeometry, glowMaterial); scene.add(sunGlow); const sunLightRange = PLANET_MIN_DISTANCE + (PLANET_COUNT * PLANET_SPACING) + 50; const sunLight = new THREE.PointLight(0xffffff, 1.5, sunLightRange ); scene.add(sunLight); }

        // Create planets
        function createPlanets() { planets.forEach(p => { if (p.geometry) p.geometry.dispose(); if (p.material) p.material.dispose(); scene.remove(p); }); planets.length = 0; for (let i = 0; i < PLANET_COUNT; i++) { const type = getRandomPlanetType(); const size = (0.5 + Math.random() * 0.7) * type.size * PLANET_SIZE_MULTIPLIER; const distance = PLANET_MIN_DISTANCE + (i * PLANET_SPACING) + (Math.random() * 5); const angle = Math.random() * Math.PI * 2; const x = Math.cos(angle) * distance; const z = Math.sin(angle) * distance; const y = (Math.random() - 0.5) * 8; const planet = createPlanetMesh(type, size); planet.position.set(x, y, z); planet.userData = { type: type, orbitDistance: distance, orbitSpeed: 0.001 / Math.sqrt(distance), orbitAngle: angle, rotationSpeed: 0.002 + Math.random() * 0.003, radius: size }; scene.add(planet); planets.push(planet); } }

        // Simplified Planet Texture Generation
        function createPlanetTexture(type) { const canvas = document.createElement('canvas'); canvas.width = 512; canvas.height = 256; const ctx = canvas.getContext('2d'); const baseColorHex = type.colors[Math.floor(Math.random() * type.colors.length)]; _color.setHex(baseColorHex); const baseHsl = { h: 0, s: 0, l: 0 }; _color.getHSL(baseHsl); ctx.fillStyle = `hsl(${baseHsl.h * 360}, ${baseHsl.s * 100}%, ${baseHsl.l * 100}%)`; ctx.fillRect(0, 0, canvas.width, canvas.height); const numFeatures = 20 + Math.random() * 30; for (let i = 0; i < numFeatures; i++) { const hueShift = (Math.random() - 0.5) * 30; const satShift = (Math.random() - 0.5) * 30; const lightShift = (Math.random() - 0.5) * 40; const featureColor = `hsla(${baseHsl.h * 360 + hueShift}, ${Math.max(0, Math.min(100, baseHsl.s * 100 + satShift))}%, ${Math.max(5, Math.min(95, baseHsl.l * 100 + lightShift))}%, ${0.2 + Math.random() * 0.4})`; const x = Math.random() * canvas.width; const y = Math.random() * canvas.height; const radius = 10 + Math.random() * 40; ctx.fillStyle = featureColor; ctx.beginPath(); ctx.arc(x, y, radius, 0, Math.PI * 2); ctx.fill(); } if (type.category === 'Gassy') { const numBands = 5 + Math.floor(Math.random() * 5); const bandHeight = canvas.height / numBands; for (let i = 0; i < numBands; i++) { const hueShift = (Math.random() - 0.5) * 40; const satShift = (Math.random() - 0.5) * 20; const lightShift = (Math.random() - 0.5) * 30; const bandColor = `hsla(${baseHsl.h * 360 + hueShift}, ${Math.max(0, Math.min(100, baseHsl.s * 100 + satShift))}%, ${Math.max(10, Math.min(90, baseHsl.l * 100 + lightShift))}%, ${0.1 + Math.random() * 0.2})`; ctx.fillStyle = bandColor; ctx.fillRect(0, i * bandHeight, canvas.width, bandHeight); } } const texture = new THREE.CanvasTexture(canvas); texture.wrapS = THREE.RepeatWrapping; texture.needsUpdate = true; return texture; }

        // Create a single planet mesh
        function createPlanetMesh(type, size) { const geometry = new THREE.SphereGeometry(size, 32, 16); const planetTexture = createPlanetTexture(type); const material = new THREE.MeshPhongMaterial({ map: planetTexture, shininess: type.category === 'Rocky' ? 10 : 5, bumpMap: planetTexture, bumpScale: type.bump * 0.5, }); if (type.name === 'Hot' || type.name === 'Magma') { material.emissive.setHex(0xFF4500); material.emissiveIntensity = 0.3; material.emissiveMap = planetTexture; } const planet = new THREE.Mesh(geometry, material); if (type.name === 'Ringed') { const ringGeometry = new THREE.RingGeometry(size * 1.5, size * 2.5, 64); const ringMaterial = new THREE.MeshBasicMaterial({ color: 0xAAAAAA, side: THREE.DoubleSide, transparent: true, opacity: 0.7, depthWrite: false }); const ring = new THREE.Mesh(ringGeometry, ringMaterial); ring.rotation.x = Math.PI / 2; planet.add(ring); } if (Math.random() < type.atmosphereChance) { const atmosphereGeometry = new THREE.SphereGeometry(size * 1.05, 32, 16); const atmosColor = _color.setHSL(Math.random(), 0.5, 0.7); const atmosphereMaterial = new THREE.MeshBasicMaterial({ color: atmosColor, transparent: true, opacity: Math.random() * 0.2 + 0.1, side: THREE.BackSide, depthWrite: false }); const atmosphere = new THREE.Mesh(atmosphereGeometry, atmosphereMaterial); planet.add(atmosphere); } return planet; }

        // Create the star system
        function createStarSystem() { createSun(); createPlanets(); }

        // Update HUD (Includes Shields)
        function updateHUD() { const playerHealthPercent = Math.max(0, playerHealth) / PLAYER_START_HEALTH * 100; const playerShieldPercent = Math.max(0, playerShield) / MAX_SHIELD * 100; hudPlayerHealthBarEl.style.width = `${playerHealthPercent}%`; hudPlayerShieldBarEl.style.width = `${playerShieldPercent}%`; const enemyHealthPercent = Math.max(0, enemyHealth) / ENEMY_START_HEALTH * 100; const enemyShieldPercent = Math.max(0, enemyShield) / MAX_SHIELD * 100; if (enemyHealth > 0 && enemyNameEl.textContent === '---') { enemyNameEl.textContent = currentEnemyName; } else if (enemyHealth <= 0 && enemyNameEl.textContent !== 'DESTROYED') { enemyNameEl.textContent = "DESTROYED"; } hudEnemyHealthBarEl.style.width = `${enemyHealthPercent}%`; hudEnemyShieldBarEl.style.width = `${enemyShieldPercent}%`; const heatPercent = Math.min(100, Math.max(0, weaponHeat)); hudWeaponHeatValueEl.textContent = weaponHeat.toFixed(0); hudWeaponHeatBarEl.style.width = `${heatPercent}%`; if (weaponHeat > WEAPON_MAX_HEAT * 0.8) { hudWeaponHeatBarEl.style.backgroundColor = '#ff0000'; } else if (weaponHeat > WEAPON_MAX_HEAT * 0.5) { hudWeaponHeatBarEl.style.backgroundColor = '#ffaa00'; } else { hudWeaponHeatBarEl.style.backgroundColor = '#ffff00'; } }

        // Player Ship Controls
        function handleShipControls(deltaTime) { if (!ship) return; shipVelocity.multiplyScalar(DAMPING); _forward.set(0, 0, 1).applyQuaternion(ship.quaternion); shipForwardDir.copy(_forward); const rotMultiplier = isMobile ? MOBILE_ROTATION_MULTIPLIER : 1.0; const rollMultiplier = isMobile ? MOBILE_ROLL_MULTIPLIER : 1.0; const accelMultiplier = isMobile ? MOBILE_ACCEL_MULTIPLIER : 1.0; const currentYawSpeed = YAW_SPEED * rotMultiplier; const currentPitchSpeed = PITCH_SPEED * rotMultiplier; const currentRollSpeed = ROLL_SPEED * rotMultiplier * rollMultiplier; const currentAcceleration = ACCELERATION * accelMultiplier; let wInput = keysPressed['w'] || 0; if (isAutoThrusting && !(keysPressed['s'] > 0)) { wInput = 1.0; } const sInput = keysPressed['s'] || 0; const fwdAccel = wInput - sInput; let effectiveAccel = fwdAccel * currentAcceleration; if (keysPressed['shift']) { effectiveAccel += (fwdAccel >= 0 ? 1 : (fwdAccel === 0 ? 1 : -1)) * BOOST_MULTIPLIER * currentAcceleration; } if (effectiveAccel !== 0) { shipVelocity.addScaledVector(_forward, effectiveAccel); } const yawInput = keysPressed['a'] || 0; const yawInputNeg = keysPressed['d'] || 0; const pitchInput = keysPressed['arrowup'] || 0; const pitchInputNeg = keysPressed['arrowdown'] || 0; const rollInput = keysPressed['arrowright'] || 0; const rollInputNeg = keysPressed['arrowleft'] || 0; const yawAmount = yawInput - yawInputNeg; const pitchAmount = pitchInput - pitchInputNeg; const rollAmount = rollInput - rollInputNeg; if (yawAmount !== 0) ship.rotateY(currentYawSpeed * yawAmount); if (pitchAmount !== 0) ship.rotateX(currentPitchSpeed * pitchAmount); if (rollAmount !== 0) ship.rotateZ(currentRollSpeed * rollAmount); if (shipVelocity.lengthSq() > MAX_PLAYER_SPEED * MAX_PLAYER_SPEED) { shipVelocity.normalize().multiplyScalar(MAX_PLAYER_SPEED); } ship.position.add(shipVelocity); }

        // Camera Update (Handles Lock-On and Smooth Transitions)
        function updateCameraPosition(deltaTime) { if (!ship || deltaTime <= 0) return; ship.getWorldQuaternion(_quaternion); ship.getWorldPosition(_tempVec1); _shipUp.set(0, 1, 0).applyQuaternion(_quaternion); const upLerpFactor = 1.0 - Math.pow(1.0 - CAMERA_UP_SMOOTH_SPEED, deltaTime * 60); cameraSmoothUp.lerp(_shipUp, upLerpFactor).normalize(); adjustCameraForOrientation(); _tempVec2.copy(cameraOffset).applyQuaternion(_quaternion); cameraTargetPosition.addVectors(_tempVec1, _tempVec2); const followLerpFactor = 1.0 - Math.pow(1.0 - cameraFollowSpeed, deltaTime * 60); cameraSmoothPosition.lerp(cameraTargetPosition, followLerpFactor); camera.position.copy(cameraSmoothPosition); let targetLookAtPoint; if (isCameraLockedOn && enemyShip && enemyHealth > 0) { targetLookAtPoint = enemyShip.position; } else { _forward.set(0, 0, 1).applyQuaternion(_quaternion); targetLookAtPoint = _tempVec3.copy(_tempVec1).addScaledVector(_forward, CAMERA_LOOK_AHEAD_FACTOR); } const lookAtLerpFactor = 1.0 - Math.pow(1.0 - CAMERA_LOCK_ON_SPEED, deltaTime * 60); smoothLookAtTarget.lerp(targetLookAtPoint, lookAtLerpFactor); camera.up.copy(cameraSmoothUp); camera.lookAt(smoothLookAtTarget); if (sunGlow && sun) { sunGlow.material.uniforms.viewVector.value.subVectors(camera.position, sun.position); } }

        // Collision Detection
        function checkCollisions() { if (!ship || isGameOver) return; const shipRadius = 0.5; const sunDistSq = ship.position.distanceToSquared(sun.position); const sunDeathRadiusSq = SUN_INSTA_DEATH_DISTANCE * SUN_INSTA_DEATH_DISTANCE; if (sunDistSq < sunDeathRadiusSq) { createExplosion(ship.position, 1.5, 0xffaa00); gameOver(false); return; } for (const planet of planets) { const planetDistSq = ship.position.distanceToSquared(planet.position); const planetCollisionRadius = planet.userData.radius + shipRadius; const planetCollisionRadiusSq = planetCollisionRadius * planetCollisionRadius; if (planetDistSq < planetCollisionRadiusSq) { _tempVec1.subVectors(ship.position, planet.position).normalize(); shipVelocity.reflect(_tempVec1).multiplyScalar(0.5); const penetrationDepth = planetCollisionRadius - Math.sqrt(planetDistSq); ship.position.addScaledVector(_tempVec1, penetrationDepth + 0.1); return; } } }

        // Sun Damage Logic
        function handleSunDamage(deltaTime) { if (!ship || isGameOver || !sun || deltaTime <= 0) return; const sunDistSq = ship.position.distanceToSquared(sun.position); const sunDamageRadiusSq = SUN_DAMAGE_START_DISTANCE * SUN_DAMAGE_START_DISTANCE; const now = performance.now(); if (sunDistSq < sunDamageRadiusSq) { const damage = SUN_DAMAGE_PER_SECOND * deltaTime; let damageToHealth = 0; if (playerShield > 0) { const shieldDamage = Math.min(playerShield, damage); playerShield -= shieldDamage; damageToHealth = damage - shieldDamage; playerShieldRechargeTimer = now + SHIELD_RECHARGE_DELAY_MS; } else { damageToHealth = damage; } if (damageToHealth > 0) { playerHealth -= damageToHealth; if (playerHealth <= 0) { playerHealth = 0; createExplosion(ship.position, 1.0, 0xff6600); gameOver(false); } } } }

        // --- Shield Recharge Logic ---
        function updateShields(deltaTime) { const now = performance.now(); const rechargeAmount = SHIELD_RECHARGE_RATE_PER_SEC * deltaTime; if (playerShield < MAX_SHIELD && playerHealth > 0 && now > playerShieldRechargeTimer) { playerShield = Math.min(MAX_SHIELD, playerShield + rechargeAmount); } if (enemyShield < MAX_SHIELD && enemyHealth > 0 && now > enemyShieldRechargeTimer) { enemyShield = Math.min(MAX_SHIELD, enemyShield + rechargeAmount); } }

        // Update planets/sun positions (deltaTime)
        function updatePlanets(deltaTime) { if (deltaTime <= 0) return; const timeFactor = deltaTime * 60; planets.forEach(planet => { planet.userData.orbitAngle += planet.userData.orbitSpeed * timeFactor; planet.position.x = Math.cos(planet.userData.orbitAngle) * planet.userData.orbitDistance; planet.position.z = Math.sin(planet.userData.orbitAngle) * planet.userData.orbitDistance; planet.rotation.y += planet.userData.rotationSpeed * timeFactor; }); }
        function updateSun(deltaTime) { if (deltaTime <= 0) return; const timeFactor = deltaTime * 60; if (sun) { sun.rotation.y += 0.001 * timeFactor; } }

        // Weapon Firing (Triggered by holding space)
        function fireWeapon() { const currentTime = performance.now(); if (isGameOver || !ship || weaponHeat >= WEAPON_MAX_HEAT || currentTime - lastFireTime < WEAPON_FIRE_RATE_MS) return; lastFireTime = currentTime; weaponHeat = Math.min(WEAPON_MAX_HEAT, weaponHeat + WEAPON_HEAT_PER_SHOT); ship.getWorldQuaternion(_quaternion); ship.getWorldPosition(_tempVec1); _forward.set(0, 0, 1).applyQuaternion(_quaternion); const weaponOffsetX = 0.5 * ship.scale.x; const weaponOffsetZ = 0.6 * ship.scale.z; _tempVec2.set(-weaponOffsetX, 0, weaponOffsetZ).applyQuaternion(_quaternion).add(_tempVec1); createProjectile(_tempVec2, _forward, false); _tempVec3.set(weaponOffsetX, 0, weaponOffsetZ).applyQuaternion(_quaternion).add(_tempVec1); createProjectile(_tempVec3, _forward, false); }
        function enemyFireWeapon() { if (isGameOver || !enemyShip || !ship) return; const currentTime = performance.now(); if (currentTime - enemyLastFireTime < ENEMY_FIRE_RATE_MS) return; enemyLastFireTime = currentTime; enemyShip.getWorldQuaternion(_quaternion); enemyShip.getWorldPosition(_tempVec1); _forward.set(0, 0, 1).applyQuaternion(_quaternion); const weaponOffsetX = 0.5 * enemyShip.scale.x; const weaponOffsetZ = 0.8 * enemyShip.scale.z; _tempVec2.set(-weaponOffsetX, 0, weaponOffsetZ).applyQuaternion(_quaternion).add(_tempVec1); createProjectile(_tempVec2, _forward, true); _tempVec3.set(weaponOffsetX, 0, weaponOffsetZ).applyQuaternion(_quaternion).add(_tempVec1); createProjectile(_tempVec3, _forward, true); }

        // Projectile Creation and Update (Frame-based movement, SHIELD logic added)
        const playerProjectileGeometry = new THREE.SphereGeometry(PROJECTILE_RADIUS, 6, 4); const playerProjectileMaterial = new THREE.MeshBasicMaterial({ color: PLAYER_TRAIL_COLOR }); const enemyProjectileGeometry = new THREE.SphereGeometry(PROJECTILE_RADIUS, 6, 4); const enemyProjectileMaterial = new THREE.MeshBasicMaterial({ color: ENEMY_TRAIL_COLOR });
        function createProjectile(position, direction, isEnemy) { const geometry = isEnemy ? enemyProjectileGeometry : playerProjectileGeometry; const material = isEnemy ? enemyProjectileMaterial : playerProjectileMaterial; const speed = isEnemy ? ENEMY_PROJECTILE_SPEED : PROJECTILE_SPEED; const lifespan = isEnemy ? PROJECTILE_ENEMY_LIFESPAN_MS : PROJECTILE_LIFESPAN_MS; const list = isEnemy ? enemyProjectiles : projectiles; const projectileMesh = new THREE.Mesh(geometry, material); projectileMesh.position.copy(position); scene.add(projectileMesh); list.push({ mesh: projectileMesh, velocity: direction.clone().multiplyScalar(speed), createdTime: performance.now(), lifespan: lifespan, isEnemy: isEnemy, }); }
        function updateProjectiles(deltaTime) {
            const currentTime = performance.now();
            // Player Projectiles hitting Enemy
            for (let i = projectiles.length - 1; i >= 0; i--) { const p = projectiles[i]; p.mesh.position.add(p.velocity); if (currentTime - p.createdTime > p.lifespan) { removeProjectile(p, i, projectiles); continue; } if (enemyShip && enemyHealth > 0) { const distSq = p.mesh.position.distanceToSquared(enemyShip.position); const enemyRadiusSq = 0.8 * 0.8; if (distSq < enemyRadiusSq) { let damageDealt = PROJECTILE_DAMAGE; let damageToHealth = 0; if (enemyShield > 0) { const shieldDamage = Math.min(enemyShield, damageDealt); enemyShield -= shieldDamage; damageToHealth = damageDealt - shieldDamage; enemyShieldRechargeTimer = currentTime + SHIELD_RECHARGE_DELAY_MS; } else { damageToHealth = damageDealt; } if(damageToHealth > 0) enemyHealth -= damageToHealth; createExplosion(p.mesh.position, 0.3, enemyProjectileMaterial.color); removeProjectile(p, i, projectiles); if (enemyHealth <= 0) { enemyHealth = 0; handleEnemyDestroyed(); if (!isGameOver) gameOver(true); } else { if (enemyShield <= 0 && enemyState !== 'evade') setEnemyState('evade'); } continue; } } if (checkProjectilePlanetCollision(p)) { removeProjectile(p, i, projectiles); continue; } }
            // Enemy Projectiles hitting Player
            for (let i = enemyProjectiles.length - 1; i >= 0; i--) { const p = enemyProjectiles[i]; p.mesh.position.add(p.velocity); if (currentTime - p.createdTime > p.lifespan) { removeProjectile(p, i, enemyProjectiles); continue; } if (ship && playerHealth > 0) { const distSq = p.mesh.position.distanceToSquared(ship.position); const playerRadiusSq = 0.5 * 0.5; if (distSq < playerRadiusSq) { let damageDealt = ENEMY_PROJECTILE_DAMAGE; let damageToHealth = 0; if (playerShield > 0) { const shieldDamage = Math.min(playerShield, damageDealt); playerShield -= shieldDamage; damageToHealth = damageDealt - shieldDamage; playerShieldRechargeTimer = currentTime + SHIELD_RECHARGE_DELAY_MS; } else { damageToHealth = damageDealt; } if(damageToHealth > 0) playerHealth -= damageToHealth; createExplosion(p.mesh.position, 0.3, playerProjectileMaterial.color); removeProjectile(p, i, enemyProjectiles); if (playerHealth <= 0 && !isGameOver) { playerHealth = 0; createExplosion(ship.position, 1.0, playerProjectileMaterial.color); gameOver(false); } continue; } } if (checkProjectilePlanetCollision(p)) { removeProjectile(p, i, enemyProjectiles); continue; } }
        }
        function checkProjectilePlanetCollision(projectile) { for (const planet of planets) { const planetRadiusSq = planet.userData.radius * planet.userData.radius; if (projectile.mesh.position.distanceToSquared(planet.position) < planetRadiusSq) { createExplosion(projectile.mesh.position, 0.2); return true; } } return false; }
        function removeProjectile(projectile, index, list) { if (!projectile.mesh) return; scene.remove(projectile.mesh); list.splice(index, 1); }

        // Explosion Effect (Frame-based movement)
        const explosionParticleGeometry = new THREE.SphereGeometry(0.02, 4, 4); const baseExplosionMaterial = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.9 });
        function createExplosion(position, size, color = 0xff6600) { const particleCount = Math.floor(20 * size); const explosionDuration = 800 + Math.random() * 400; const materialColor = (color === 0xff6600) ? baseExplosionMaterial.color : _color.set(color); for (let i = 0; i < particleCount; i++) { const particleMaterial = baseExplosionMaterial.clone(); if (color !== 0xff6600) particleMaterial.color.copy(materialColor); const particle = new THREE.Mesh(explosionParticleGeometry, particleMaterial); particle.scale.setScalar(size * (Math.random() * 0.5 + 0.5)); particle.position.copy(position); _tempVec1.set(Math.random() - 0.5, Math.random() - 0.5, Math.random() - 0.5) .normalize().multiplyScalar(0.1 * size); scene.add(particle); animateParticle(particle, _tempVec1.clone(), explosionDuration); } const light = new THREE.PointLight(materialColor, 1.5 * size, 4 * size); light.position.copy(position); scene.add(light); setTimeout(() => { scene.remove(light); }, 300); }
        function animateParticle(particle, velocity, duration) { const startTime = performance.now(); function update() { const elapsed = performance.now() - startTime; if (!particle.parent) return; const progress = Math.min(elapsed / duration, 1.0); particle.position.add(velocity); particle.material.opacity = 0.9 * (1.0 - progress); if (progress < 1.0) { requestAnimationFrame(update); } else { scene.remove(particle); particle.material.dispose(); } } requestAnimationFrame(update); }

        // --- Trail Effects (Enemy Duration Increased) ---
        const trailSegmentGeometry = new THREE.CylinderGeometry(TRAIL_TUBE_RADIUS, TRAIL_TUBE_RADIUS, 1, 4, 1, false); const playerTrailMaterial = new THREE.MeshBasicMaterial({ color: PLAYER_TRAIL_COLOR, transparent: true, opacity: TRAIL_OPACITY, side: THREE.DoubleSide, depthWrite: false }); const enemyTrailMaterial = new THREE.MeshBasicMaterial({ color: ENEMY_TRAIL_COLOR, transparent: true, opacity: TRAIL_OPACITY, side: THREE.DoubleSide, depthWrite: false });
        function initializeTrailEffect() { trailPoints.length = 0; trailSegments.forEach(seg => { if(seg.mesh) { scene.remove(seg.mesh); if(seg.mesh.material) seg.mesh.material.dispose(); } }); trailSegments.length = 0; if (ship) lastTrailPosition.copy(ship.position); }
        function updateTrailEffect() { if (!ship || isPaused || isGameOver) return; playerFrameCount++; if (playerFrameCount % TRAIL_UPDATE_INTERVAL_FRAMES !== 0) return; const currentPosition = ship.position; if (currentPosition.distanceToSquared(lastTrailPosition) < TRAIL_MIN_DISTANCE * TRAIL_MIN_DISTANCE) return; _tempVec1.copy(currentPosition); trailPoints.push({ position: _tempVec1.clone(), creationTime: performance.now() }); if (trailPoints.length > TRAIL_MAX_LENGTH) trailPoints.shift(); if (trailPoints.length >= 2) createTrailSegment(trailPoints[trailPoints.length - 2].position, trailPoints[trailPoints.length - 1].position, false); lastTrailPosition.copy(_tempVec1); }
        function initializeEnemyTrailEffect() { enemyTrailPoints.length = 0; enemyTrailSegments.forEach(seg => { if(seg.mesh) { scene.remove(seg.mesh); if(seg.mesh.material) seg.mesh.material.dispose(); } }); enemyTrailSegments.length = 0; if (enemyShip) lastEnemyTrailPosition.copy(enemyShip.position); }
        function updateEnemyTrailEffect() { if (!enemyShip || enemyHealth <= 0 || isPaused || isGameOver) return; enemyFrameCount++; if (enemyFrameCount % TRAIL_UPDATE_INTERVAL_FRAMES !== 0) return; const currentPosition = enemyShip.position; if (currentPosition.distanceToSquared(lastEnemyTrailPosition) < TRAIL_MIN_DISTANCE * TRAIL_MIN_DISTANCE) return; _tempVec1.copy(currentPosition); enemyTrailPoints.push({ position: _tempVec1.clone(), creationTime: performance.now() }); if (enemyTrailPoints.length > TRAIL_MAX_LENGTH) enemyTrailPoints.shift(); if (enemyTrailPoints.length >= 2) createTrailSegment(enemyTrailPoints[enemyTrailPoints.length - 2].position, enemyTrailPoints[enemyTrailPoints.length - 1].position, true); lastEnemyTrailPosition.copy(_tempVec1); }
        function createTrailSegment(startPoint, endPoint, isEnemy) { const distance = startPoint.distanceTo(endPoint); if (distance < 0.01) return; const material = isEnemy ? enemyTrailMaterial.clone() : playerTrailMaterial.clone(); const list = isEnemy ? enemyTrailSegments : trailSegments; const trailSegment = new THREE.Mesh(trailSegmentGeometry, material); _tempVec1.addVectors(startPoint, endPoint).multiplyScalar(0.5); trailSegment.position.copy(_tempVec1); trailSegment.scale.y = distance; trailSegment.lookAt(endPoint); trailSegment.rotateX(Math.PI / 2); scene.add(trailSegment); list.push({ mesh: trailSegment, creationTime: performance.now() }); }
        function fadeTrailSegments(list, isEnemy = false) {
             const currentTime = performance.now();
             const fadeDuration = isEnemy ? ENEMY_TRAIL_FADE_DURATION_MS : PLAYER_TRAIL_FADE_DURATION_MS; // Longer duration for enemy
             for (let i = list.length - 1; i >= 0; i--) { const segment = list[i]; const age = currentTime - segment.creationTime; const lifeRatio = age / fadeDuration; if (lifeRatio >= 1.0) { scene.remove(segment.mesh); segment.mesh.material.dispose(); list.splice(i, 1); } else { segment.mesh.material.opacity = TRAIL_OPACITY * (1.0 - lifeRatio); } }
         }

        // Thruster Animation
        function animateThrusters() { if (!ship) return; const baseThrust = 0.2; let wInput = keysPressed['w'] || 0; if(isAutoThrusting && !(keysPressed['s'] > 0)) wInput = 1.0; let currentThrust = baseThrust; if (wInput > 0.1) currentThrust = Math.max(currentThrust, wInput); if (keysPressed['shift']) currentThrust = Math.max(currentThrust, 1.2); if ((keysPressed['s'] || 0) > 0.1) currentThrust = 0.4; ship.children.forEach(child => { if (child.userData.isThruster) { const pulseAmount = Math.random() * 0.3 + 0.7; child.scale.z = currentThrust * pulseAmount; child.material.opacity = Math.min(0.8, currentThrust * (Math.random() * 0.2 + 0.8)); child.visible = currentThrust > 0.01; } else if (child.userData.isThrusterLight) { child.intensity = currentThrust * 1.5 * (Math.random() * 0.3 + 0.85); child.visible = currentThrust > 0.01; } }); }

        // Enemy Ship Creation (Spawns near furthest planet)
        function createEnemyShip() { enemyShip = new THREE.Group(); const enemyColor = ENEMY_TRAIL_COLOR; const bodyColor = _color.set(enemyColor).multiplyScalar(0.6).getHex(); const thrusterColor = 0xff6600; const coneGeometry = new THREE.ConeGeometry(0.5, 2, 4); const bodyGeometry = new THREE.BoxGeometry(0.7, 0.4, 1); const wingGeometry = new THREE.BoxGeometry(2, 0.1, 0.7); const thrusterGeometry = new THREE.CylinderGeometry(0.15, 0.25, 0.5, 8); const cockpitGeometry = new THREE.SphereGeometry(0.3, 16, 8, 0, Math.PI * 2, 0, Math.PI / 2); const weaponGeometry = new THREE.BoxGeometry(0.2, 0.1, 0.3); const mainMaterial = new THREE.MeshPhongMaterial({ color: enemyColor }); const bodyMaterial = new THREE.MeshPhongMaterial({ color: bodyColor }); const wingMaterial = new THREE.MeshPhongMaterial({ color: enemyColor }); const thrusterMaterial = new THREE.MeshBasicMaterial({ color: thrusterColor, transparent: true, opacity: 0.8 }); const cockpitMaterial = new THREE.MeshPhongMaterial({ color: 0xffcc00, transparent: true, opacity: 0.6, shininess: 80 }); const weaponMaterial = new THREE.MeshPhongMaterial({ color: 0x444444 }); const cone = new THREE.Mesh(coneGeometry, mainMaterial); cone.rotation.x = Math.PI / 2; cone.position.z = 0.8; enemyShip.add(cone); const body = new THREE.Mesh(bodyGeometry, bodyMaterial); enemyShip.add(body); const leftWing = new THREE.Mesh(wingGeometry, wingMaterial); leftWing.position.x = -0.7; enemyShip.add(leftWing); const rightWing = new THREE.Mesh(wingGeometry, wingMaterial); rightWing.position.x = 0.7; enemyShip.add(rightWing); const cockpit = new THREE.Mesh(cockpitGeometry, cockpitMaterial); cockpit.rotation.x = Math.PI; cockpit.position.set(0, 0.2, 0.3); enemyShip.add(cockpit); const leftThruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial.clone()); leftThruster.rotation.x = -Math.PI / 2; leftThruster.position.set(-0.25, 0, -0.7); enemyShip.add(leftThruster); const rightThruster = new THREE.Mesh(thrusterGeometry, thrusterMaterial.clone()); rightThruster.rotation.x = -Math.PI / 2; rightThruster.position.set(0.25, 0, -0.7); enemyShip.add(rightThruster); enemyShip.userData.thrusters = [leftThruster, rightThruster]; const leftWeapon = new THREE.Mesh(weaponGeometry, weaponMaterial); leftWeapon.position.set(-0.5, 0, 0.8); enemyShip.add(leftWeapon); const rightWeapon = new THREE.Mesh(weaponGeometry, weaponMaterial); rightWeapon.position.set(0.5, 0, 0.8); enemyShip.add(rightWeapon); enemyShip.scale.set(0.2, 0.2, 0.2); enemyShip.rotation.order = 'YXZ'; enemyShip.userData.isEnemy = true;
            let spawnPlanet = null; if (planets.length > 0) { spawnPlanet = planets[planets.length - 1]; } if (spawnPlanet) { const planetRadius = spawnPlanet.userData.radius || 5; const spawnDistance = planetRadius + 8 + Math.random() * 7; const spawnAngle = Math.random() * Math.PI * 2; const spawnHeight = (Math.random() - 0.5) * 6; _tempVec1.set( Math.cos(spawnAngle) * spawnDistance, spawnHeight, Math.sin(spawnAngle) * spawnDistance ); enemyShip.position.copy(spawnPlanet.position).add(_tempVec1); if(ship) enemyShip.lookAt(ship.position); else enemyShip.lookAt(0,0,0); } else { enemyShip.position.set(-15, 8, -15); }
            currentEnemyName = generateEnemyName(); if(enemyNameEl) enemyNameEl.textContent = currentEnemyName; enemyState = 'patrol'; generatePatrolTarget(); enemyHealth = ENEMY_START_HEALTH; enemyShield = MAX_SHIELD; enemyShieldRechargeTimer = 0; scene.add(enemyShip); initializeEnemyTrailEffect(); }

        // --- Enhanced Enemy AI Update (Shield Logic) ---
        function updateEnemyShip(deltaTime) { if (!enemyShip || enemyHealth <= 0 || !ship || isGameOver) { if (enemyShip && enemyShip.userData.thrusters) enemyShip.userData.thrusters.forEach(t => t.visible = false); return; } const timeFactor = deltaTime > 0 ? deltaTime * 60 : 1; enemyStateTimer -= timeFactor; if (enemyStateTimer <= 0 || (enemyShield <= 0 && enemyState !== 'evade')) chooseEnemyState(); if (enemyBoostTimer > 0) enemyBoostTimer -= timeFactor; const playerPosition = ship.position; const enemyPosition = enemyShip.position; _playerVel.copy(shipVelocity); if (isNaN(enemyPosition.x) || isNaN(playerPosition.x)) { console.error("NaN position detected!"); isPaused = true; return; } const distanceToPlayerSq = enemyPosition.distanceToSquared(playerPosition); const distanceToPlayer = Math.sqrt(distanceToPlayerSq); const directionToPlayer = _tempVec1.subVectors(playerPosition, enemyPosition).normalize(); const predictionTime = (distanceToPlayer / (ENEMY_PROJECTILE_SPEED * 60)) * ENEMY_LEAD_FACTOR; const predictedPlayerPos = _tempVec2.copy(playerPosition).addScaledVector(_playerVel, predictionTime); const directionToPredicted = _tempVec3.subVectors(predictedPlayerPos, enemyPosition).normalize(); let currentMaxSpeed = ENEMY_MAX_SPEED; let baseAccelMagnitude = 0.001; const acceleration = _vector3Pool.get().set(0, 0, 0);
             if (enemyShield <= 0 && enemyState !== 'evade') { setEnemyState('evade'); } // Force evade if shield broken
             switch (enemyState) { case 'patrol': baseAccelMagnitude = 0.0005; currentMaxSpeed = ENEMY_PATROL_SPEED; if (enemyPatrolTarget.lengthSq() === 0 || enemyPosition.distanceToSquared(enemyPatrolTarget) < 25) { generatePatrolTarget(); } _forward.subVectors(enemyPatrolTarget, enemyPosition).normalize(); acceleration.addScaledVector(_forward, baseAccelMagnitude); if (distanceToPlayer < PATROL_DETECTION_RANGE) { setEnemyState('chase'); } break; case 'chase': baseAccelMagnitude = 0.002; currentMaxSpeed = ENEMY_MAX_SPEED * 1.1; acceleration.addScaledVector(directionToPredicted, baseAccelMagnitude); if (distanceToPlayer > 20 && enemyBoostTimer <= 0 && Math.random() < 0.02) { enemyBoostTimer = 60; } if (enemyBoostTimer > 0) currentMaxSpeed = ENEMY_BOOST_SPEED; if (distanceToPlayer < ENEMY_OPTIMAL_DISTANCE + 5) { setEnemyState('attack'); } break; case 'attack': if (enemyShield <= 0) { setEnemyState('evade'); break; } baseAccelMagnitude = 0.0015; currentMaxSpeed = ENEMY_MAX_SPEED; const targetDir = directionToPredicted; if (distanceToPlayer > ENEMY_OPTIMAL_DISTANCE + 3) { acceleration.addScaledVector(targetDir, baseAccelMagnitude); } else if (distanceToPlayer < ENEMY_OPTIMAL_DISTANCE - 2) { acceleration.addScaledVector(targetDir, -baseAccelMagnitude * 0.6); } else { const strafeDir = _forward.crossVectors(targetDir, _up).normalize(); if (enemyShip.userData.strafeDirection === undefined) enemyShip.userData.strafeDirection = (Math.random() < 0.5) ? 1 : -1; acceleration.addScaledVector(strafeDir, baseAccelMagnitude * 0.8 * enemyShip.userData.strafeDirection); if (Math.random() < 0.1) { acceleration.y += (Math.random() - 0.5) * baseAccelMagnitude * 0.6; } } enemyShip.getWorldDirection(_forward); const dotToTarget = _forward.dot(targetDir); if (dotToTarget > ENEMY_FIRING_ANGLE_THRESHOLD && distanceToPlayer < ENEMY_MAX_RANGE) { enemyFireWeapon(); } if (Math.random() < 0.015) { chooseEnemyState(); } break; case 'evade': baseAccelMagnitude = 0.002; currentMaxSpeed = ENEMY_MAX_SPEED * 1.2; acceleration.addScaledVector(directionToPlayer, -baseAccelMagnitude); acceleration.x += (Math.random() - 0.5) * EVADE_JITTER_STRENGTH; acceleration.y += (Math.random() - 0.5) * EVADE_JITTER_STRENGTH; acceleration.z += (Math.random() - 0.5) * EVADE_JITTER_STRENGTH; enemyShip.rotateZ((Math.random() - 0.5) * EVADE_ROLL_RATE); if (enemyBoostTimer <= 0 && Math.random() < EVADE_BOOST_CHANCE) { enemyBoostTimer = 45; } if (enemyBoostTimer > 0) currentMaxSpeed = ENEMY_BOOST_SPEED * 1.1; if (enemyShield > MAX_SHIELD * 0.5 && distanceToPlayer > 20) { chooseEnemyState(); } avoidPlanets(true); break; case 'maneuver': baseAccelMagnitude = 0.0018; currentMaxSpeed = ENEMY_MAX_SPEED * 1.1; if (enemyManeuverTarget.lengthSq() === 0 || enemyPosition.distanceToSquared(enemyManeuverTarget) < 36) { generateManeuverTarget(true); } _forward.subVectors(enemyManeuverTarget, enemyPosition).normalize(); acceleration.addScaledVector(_forward, baseAccelMagnitude); if (enemyBoostTimer <= 0 && Math.random() < 0.03) { enemyBoostTimer = 50; } if (enemyBoostTimer > 0) currentMaxSpeed = ENEMY_BOOST_SPEED; if (Math.random() < 0.01) { chooseEnemyState(); } break; }
             enemyVelocity.add(acceleration); _vector3Pool.release(acceleration); if (enemyVelocity.lengthSq() > currentMaxSpeed * currentMaxSpeed) { enemyVelocity.normalize().multiplyScalar(currentMaxSpeed); } enemyVelocity.multiplyScalar(ENEMY_DAMPING); let lookTargetPos = _vector3Pool.get(); if (enemyState === 'attack') { lookTargetPos.copy(predictedPlayerPos); } else if (enemyVelocity.lengthSq() > 0.001) { lookTargetPos.addVectors(enemyPosition, enemyVelocity); } else { lookTargetPos.copy(enemyPosition).add(_forward.set(0,0,1).applyQuaternion(enemyShip.quaternion)); } enemyShip.lookAt(lookTargetPos); _vector3Pool.release(lookTargetPos); _tempVec1.copy(enemyVelocity).projectOnPlane(_up); _tempVec2.set(0,0,1).applyQuaternion(enemyShip.quaternion).projectOnPlane(_up); if (_tempVec1.lengthSq() > 0.01 && _tempVec2.lengthSq() > 0.01) { let turnAngle = _tempVec2.angleTo(_tempVec1); _tempVec3.crossVectors(_tempVec2, _tempVec1); if (_tempVec3.y < 0) { turnAngle *= -1; } const maxBankAngle = Math.PI / 6; const targetRoll = Math.max(-maxBankAngle, Math.min(maxBankAngle, -turnAngle * 1.5)); const rollDifference = targetRoll - enemyShip.rotation.z; enemyShip.rotateZ(rollDifference * 0.1); } else { enemyShip.rotateZ(-enemyShip.rotation.z * 0.05); } enemyPosition.add(enemyVelocity); if (enemyPosition.lengthSq() > ENEMY_MAX_CENTER_DISTANCE * ENEMY_MAX_CENTER_DISTANCE) { _tempVec3.copy(enemyPosition).negate().normalize(); enemyVelocity.addScaledVector(_tempVec3, 0.002); } avoidPlanets(); const speedRatio = Math.min(1.0, enemyVelocity.length() / currentMaxSpeed); if (enemyShip.userData.thrusters) { enemyShip.userData.thrusters.forEach(thruster => { const pulse = Math.random() * 0.2 + 0.8; thruster.scale.y = speedRatio * pulse; thruster.material.opacity = 0.8 * speedRatio; thruster.visible = speedRatio > 0.05; }); } }
        function avoidPlanets(isEvading = false) { if (!enemyShip) return; const avoidanceStrength = isEvading ? ENEMY_AVOIDANCE_STRENGTH * 1.5 : ENEMY_AVOIDANCE_STRENGTH; for (const planet of planets) { const distanceSq = enemyShip.position.distanceToSquared(planet.position); const avoidanceRadius = planet.userData.radius + ENEMY_AVOIDANCE_DISTANCE; if (distanceSq < avoidanceRadius * avoidanceRadius) { const distance = Math.sqrt(distanceSq); const avoidForce = (avoidanceRadius - distance) / ENEMY_AVOIDANCE_DISTANCE; _tempVec1.subVectors(enemyShip.position, planet.position).normalize(); enemyVelocity.addScaledVector(_tempVec1, avoidanceStrength * avoidForce); } } }
        function chooseEnemyState() { if (!ship || !enemyShip) return; const distanceToPlayer = enemyShip.position.distanceTo(ship.position); const healthRatio = enemyHealth / ENEMY_START_HEALTH; const shieldRatio = enemyShield / MAX_SHIELD; let newState = 'chase'; if (shieldRatio <= 0.01) { newState = 'evade'; } else if (healthRatio < 0.3 && shieldRatio < 0.5) { newState = (Math.random() < 0.8) ? 'evade' : 'maneuver'; } else if (shieldRatio < 0.5) { newState = (Math.random() < 0.6) ? 'evade' : 'maneuver'; } else if (distanceToPlayer > PATROL_DETECTION_RANGE * 1.5) { newState = 'patrol'; } else if (distanceToPlayer > ENEMY_OPTIMAL_DISTANCE + 10) { newState = (Math.random() < 0.8) ? 'chase' : 'maneuver'; } else if (distanceToPlayer > ENEMY_OPTIMAL_DISTANCE - 3) { newState = (Math.random() < 0.7) ? 'attack' : 'maneuver'; } else { newState = (Math.random() < 0.55) ? 'attack' : (Math.random() < 0.85 ? 'maneuver' : 'evade'); } setEnemyState(newState); }
        function setEnemyState(state) { if (enemyState === state && enemyStateTimer > 0) return; enemyState = state; enemyShip.userData.strafeDirection = undefined; enemyBoostTimer = 0; let durationFrames = 120 + Math.random() * 120; switch(state) { case 'patrol': durationFrames = 300 + Math.random() * 300; generatePatrolTarget(); break; case 'chase': durationFrames = 180 + Math.random() * 180; break; case 'attack': durationFrames = 150 + Math.random() * 210; break; case 'evade': durationFrames = 90 + Math.random() * 90; break; case 'maneuver': durationFrames = 120 + Math.random() * 150; generateManeuverTarget(ship !== null); break; } enemyStateTimer = durationFrames; }
        function generatePatrolTarget() { if (planets.length > 0 && Math.random() < 0.7) { const targetPlanet = planets[Math.floor(Math.random() * planets.length)]; const offsetDist = (targetPlanet.userData.radius || 5) + 10 + Math.random() * 10; const angle = Math.random() * Math.PI * 2; const height = (Math.random() - 0.5) * 10; enemyPatrolTarget.set( targetPlanet.position.x + Math.cos(angle) * offsetDist, targetPlanet.position.y + height, targetPlanet.position.z + Math.sin(angle) * offsetDist ); } else { const patrolRadius = ENEMY_MAX_CENTER_DISTANCE * 0.8; enemyPatrolTarget.set( (Math.random() - 0.5) * 2 * patrolRadius, (Math.random() - 0.5) * 20, (Math.random() - 0.5) * 2 * patrolRadius ); } if (enemyPatrolTarget.length() < SUN_DAMAGE_START_DISTANCE + 10) { enemyPatrolTarget.normalize().multiplyScalar(SUN_DAMAGE_START_DISTANCE + 10 + Math.random() * 10); } }
        function generateManeuverTarget(tryFlank = false) { if (tryFlank && ship) { ship.getWorldDirection(_forward); _tempVec1.copy(ship.position); _playerVel.copy(shipVelocity); const behindDist = 8 + Math.random() * 4; const offsetDist = 4 + Math.random() * 4; _tempVec2.copy(_tempVec1).addScaledVector(_forward, -behindDist); _tempVec3.crossVectors(_forward, _up).normalize(); const verticalOffset = _up.clone(); _tempVec2.addScaledVector(_tempVec3, (Math.random() - 0.5) * 2 * offsetDist); _tempVec2.addScaledVector(verticalOffset, (Math.random() - 0.5) * 2 * offsetDist); enemyManeuverTarget.copy(_tempVec2); } else { const basePos = enemyShip.position; const offset = _tempVec1.set( (Math.random() - 0.5) * 30, (Math.random() - 0.5) * 15, (Math.random() - 0.5) * 30 ); enemyManeuverTarget.addVectors(basePos, offset); } enemyManeuverTarget.clampLength(0, ENEMY_MAX_CENTER_DISTANCE); if (enemyManeuverTarget.length() < SUN_DAMAGE_START_DISTANCE + 5) { enemyManeuverTarget.normalize().multiplyScalar(SUN_DAMAGE_START_DISTANCE + 5 + Math.random() * 5); } for (const planet of planets) { const safeRadius = planet.userData.radius + ENEMY_AVOIDANCE_DISTANCE; const distSq = enemyManeuverTarget.distanceToSquared(planet.position); if (distSq < safeRadius * safeRadius) { _tempVec1.subVectors(enemyManeuverTarget, planet.position).normalize(); enemyManeuverTarget.addScaledVector(_tempVec1, safeRadius - Math.sqrt(distSq) + 1); } } }
        function handleEnemyDestroyed() { if (!enemyShip) return; createExplosion(enemyShip.position, 1.2, enemyProjectileMaterial.color); scene.remove(enemyShip); if (enemyShip.userData.thrusters) { enemyShip.userData.thrusters.forEach(t => { if(t.material) t.material.dispose(); }); } enemyShip = null; if(enemyNameEl) enemyNameEl.textContent = "DESTROYED"; if(waypointIndicatorMesh) waypointIndicatorMesh.visible = false; isCameraLockedOn = false; document.body.classList.remove('lock-on-active'); if(lockOnButtonMobileEl) lockOnButtonMobileEl.classList.remove('lock-on-active'); }
        function gameOver(playerWon) { if (isGameOver) return; isGameOver = true; isPaused = true; gameOverMessageEl.innerHTML = playerWon ? 'VICTORY!<br>Enemy Destroyed' : 'GAME OVER<br>Ship Destroyed'; gameOverMessageEl.style.color = playerWon ? '#00ff00' : '#ff0000'; gameOverMessageEl.style.display = 'block'; restartButtonEl.style.display = 'block'; if (!playerWon && ship) { scene.remove(ship); ship = null; } if(waypointIndicatorMesh) waypointIndicatorMesh.visible = false; isAutoThrusting = false; if(autoThrustButtonMobileEl) autoThrustButtonMobileEl.classList.remove('auto-thrust-active'); isCameraLockedOn = false; document.body.classList.remove('lock-on-active'); if(lockOnButtonMobileEl) lockOnButtonMobileEl.classList.remove('lock-on-active'); }

        // --- Waypoint Indicator Update (3D Cone) ---
        function updateWaypointIndicator() { if (!waypointIndicatorMesh) return; if (!enemyShip || enemyHealth <= 0 || isGameOver) { waypointIndicatorMesh.visible = false; return; } waypointIndicatorMesh.visible = true; const targetWorldPos = enemyShip.position; _tempVec1.copy(targetWorldPos).applyMatrix4(camera.matrixWorldInverse); waypointIndicatorMesh.up.set(0, 1, 0); waypointIndicatorMesh.lookAt(_tempVec1); }

        // --- Event Listeners (Desktop + Common + LockOn) ---
        function setupEventListeners() { window.addEventListener('keydown', (e) => { if(isMobile) return; const keyLower = e.key.toLowerCase(); const effectiveKey = (e.key === 'Shift') ? 'shift' : keyLower; keysPressed[effectiveKey] = true; if ([' ', 'arrowup', 'arrowdown', 'arrowleft', 'arrowright', 'shift', 'w', 'a', 's', 'd', 'e'].includes(effectiveKey)) e.preventDefault(); }); window.addEventListener('keyup', (e) => { if(isMobile) return; const keyLower = e.key.toLowerCase(); const effectiveKey = (e.key === 'Shift') ? 'shift' : keyLower; keysPressed[effectiveKey] = false; if (keyLower === 'p' && !isGameOver) { isPaused = !isPaused; } if (keyLower === 'r') { isCameraLockedOn = false; document.body.classList.remove('lock-on-active'); if(lockOnButtonMobileEl) lockOnButtonMobileEl.classList.remove('lock-on-active'); cameraFollowSpeed = CAMERA_DEFAULT_FOLLOW_SPEED; defaultCamDistance = CAMERA_BASE_DISTANCE; adjustCameraForOrientation(); } if (keyLower === '-') { cameraFollowSpeed = Math.max(0.01, cameraFollowSpeed - 0.02); } if (keyLower === '=' || keyLower === '+') { cameraFollowSpeed = Math.min(0.5, cameraFollowSpeed + 0.02); } if (keyLower === 'e') { isCameraLockedOn = !isCameraLockedOn; document.body.classList.toggle('lock-on-active', isCameraLockedOn); if (lockOnButtonMobileEl) lockOnButtonMobileEl.classList.toggle('lock-on-active', isCameraLockedOn); } }); let isDragging = false; let previousMouseX = 0; let previousMouseY = 0; renderer.domElement.addEventListener('mousedown', (e) => { if(isMobile) return; isDragging = true; previousMouseX = e.clientX; previousMouseY = e.clientY; }); renderer.domElement.addEventListener('mousemove', (e) => { if(isMobile || !isDragging) return; previousMouseX = e.clientX; previousMouseY = e.clientY; }); renderer.domElement.addEventListener('mouseup', (e) => { if(isMobile) return; isDragging = false; }); renderer.domElement.addEventListener('mouseleave', (e) => { if(isMobile) return; isDragging = false; }); renderer.domElement.addEventListener('wheel', (e) => { if(isMobile) return; e.preventDefault(); const zoomAmount = e.deltaY * 0.01; defaultCamDistance = Math.max(CAMERA_MIN_DISTANCE, Math.min(CAMERA_MAX_DISTANCE, defaultCamDistance + zoomAmount)); adjustCameraForOrientation(); }, { passive: false }); window.addEventListener('resize', () => { camera.aspect = window.innerWidth / window.innerHeight; camera.updateProjectionMatrix(); renderer.setSize(window.innerWidth, window.innerHeight); adjustCameraForOrientation(); }); window.addEventListener('orientationchange', adjustCameraForOrientation); restartButtonEl.addEventListener('click', () => { location.reload(); }); controlsButtonEl.addEventListener('click', () => { controlsModalEl.style.display = (controlsModalEl.style.display === 'block') ? 'none' : 'block'; }); closeControlsButtonEl.addEventListener('click', () => { controlsModalEl.style.display = 'none'; }); window.addEventListener('click', (event) => { if (controlsModalEl.style.display === 'block' && !controlsModalEl.contains(event.target) && event.target !== controlsButtonEl) { controlsModalEl.style.display = 'none'; } }); }

        // --- Mobile Controls Setup (Analog Input Logic + New Buttons) ---
        function setupMobileControls() { if (!isMobile || !rightStickBaseEl) return; const getClampedAnalogValue = (delta, maxDelta) => { const norm = delta / maxDelta; return Math.max(0, Math.min(1, (Math.abs(norm) - STICK_DEADZONE) / (1 - STICK_DEADZONE))) * Math.sign(norm); }; const handleStickStart = (stick, touch, event) => { stick.active = true; stick.touchId = touch.identifier; const rect = stick.baseElement.getBoundingClientRect(); stick.centerX = rect.left + rect.width / 2; stick.centerY = rect.top + rect.height / 2; stick.startX = touch.clientX - stick.centerX; stick.startY = touch.clientY - stick.centerY; stick.deltaX = 0; stick.deltaY = 0; stick.knobElement.style.transform = `translate(-50%, -50%)`; }; const handleStickMove = (stick, touch) => { if (!stick.active || stick.touchId !== touch.identifier) return; stick.deltaX = touch.clientX - stick.centerX; stick.deltaY = touch.clientY - stick.centerY; const dist = Math.sqrt(stick.deltaX * stick.deltaX + stick.deltaY * stick.deltaY); const radius = STICK_RADIUS; if (dist > radius) { stick.deltaX = (stick.deltaX / dist) * radius; stick.deltaY = (stick.deltaY / dist) * radius; } stick.knobElement.style.transform = `translate(calc(-50% + ${stick.deltaX}px), calc(-50% + ${stick.deltaY}px))`; const analogX = getClampedAnalogValue(stick.deltaX, radius); const analogY = getClampedAnalogValue(stick.deltaY, radius); if (stick === rightStick) { keysPressed['arrowup'] = Math.max(0, -analogY); keysPressed['arrowdown'] = Math.max(0, analogY); keysPressed['arrowleft'] = Math.max(0, -analogX); keysPressed['arrowright'] = Math.max(0, analogX); } }; const handleStickEnd = (stick, touch) => { if (!stick.active || stick.touchId !== touch.identifier) return; stick.active = false; stick.touchId = null; stick.deltaX = 0; stick.deltaY = 0; stick.knobElement.style.transform = `translate(-50%, -50%)`; if (stick === rightStick) { keysPressed['arrowup'] = 0; keysPressed['arrowdown'] = 0; keysPressed['arrowleft'] = 0; keysPressed['arrowright'] = 0; } }; rightStick.baseElement = rightStickBaseEl; rightStick.knobElement = rightStickKnobEl; rightStickBaseEl.addEventListener('touchstart', (e) => { e.preventDefault(); for(let i=0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i]; const rect = rightStickBaseEl.getBoundingClientRect(); if (touch.clientX >= rect.left && touch.clientX <= rect.right && touch.clientY >= rect.top && touch.clientY <= rect.bottom) { if (!rightStick.active) { handleStickStart(rightStick, touch, e); break; } } } }, { passive: false }); boostButtonMobileEl.addEventListener('touchstart', (e) => { e.preventDefault(); keysPressed['shift'] = true; }, { passive: false }); boostButtonMobileEl.addEventListener('touchend', (e) => { keysPressed['shift'] = false; }); boostButtonMobileEl.addEventListener('touchcancel', (e) => { keysPressed['shift'] = false; }); thrustButtonMobileEl.addEventListener('touchstart', (e) => { e.preventDefault(); keysPressed['w'] = 1.0; isAutoThrusting = false; autoThrustButtonMobileEl.classList.remove('auto-thrust-active'); }, { passive: false }); thrustButtonMobileEl.addEventListener('touchend', (e) => { keysPressed['w'] = 0; }); thrustButtonMobileEl.addEventListener('touchcancel', (e) => { keysPressed['w'] = 0; }); autoThrustButtonMobileEl.addEventListener('touchstart', (e) => { e.preventDefault(); isAutoThrusting = !isAutoThrusting; autoThrustButtonMobileEl.classList.toggle('auto-thrust-active', isAutoThrusting); if(isAutoThrusting) keysPressed['w'] = 0; }, { passive: false }); fireButtonLeftEl.addEventListener('touchstart', (e) => { e.preventDefault(); keysPressed[' '] = true; }, { passive: false }); fireButtonLeftEl.addEventListener('touchend', (e) => { keysPressed[' '] = false; }); fireButtonLeftEl.addEventListener('touchcancel', (e) => { keysPressed[' '] = false; }); lockOnButtonMobileEl.addEventListener('touchstart', (e) => { e.preventDefault(); isCameraLockedOn = !isCameraLockedOn; lockOnButtonMobileEl.classList.toggle('lock-on-active', isCameraLockedOn); document.body.classList.toggle('lock-on-active', isCameraLockedOn);}, { passive: false }); window.addEventListener('touchmove', (e) => { e.preventDefault(); for(let i=0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i]; if (rightStick.active && rightStick.touchId === touch.identifier) { handleStickMove(rightStick, touch); } } }, { passive: false }); window.addEventListener('touchend', (e) => { for(let i=0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i]; if (rightStick.active && rightStick.touchId === touch.identifier) { handleStickEnd(rightStick, touch); } } }); window.addEventListener('touchcancel', (e) => { for(let i=0; i < e.changedTouches.length; i++) { const touch = e.changedTouches[i]; if (rightStick.active && rightStick.touchId === touch.identifier) { handleStickEnd(rightStick, touch); } } }); }

        // --- Vector Pool ---
        const _vector3Pool = { pool: [], get: function() { return this.pool.pop() || new THREE.Vector3(); }, release: function(v) { this.pool.push(v); } };

        // --- Animation Loop ---
        function animate(timestamp) { requestAnimationFrame(animate); if (timestamp === undefined || lastTimestamp === 0) { lastTimestamp = timestamp || performance.now(); return; } const deltaTime = Math.max(0, Math.min(0.05, (timestamp - lastTimestamp) / 1000)); lastTimestamp = timestamp; if (!isPaused) { const coolingAmount = WEAPON_COOLING_RATE_PER_SEC * deltaTime; weaponHeat = Math.max(0, weaponHeat - coolingAmount); updateShields(deltaTime); updatePlanets(deltaTime); updateSun(deltaTime); fadeTrailSegments(trailSegments, false); fadeTrailSegments(enemyTrailSegments, true); handleSunDamage(deltaTime); handleShipControls(deltaTime); updateEnemyShip(deltaTime); updateProjectiles(deltaTime); updateTrailEffect(); updateEnemyTrailEffect(); checkCollisions(); animateThrusters(); if (keysPressed[' ']) { fireWeapon(); } updateCameraPosition(deltaTime); updateHUD(); updateWaypointIndicator(); } else if (isGameOver) { updateHUD(); } try { renderer.render(scene, camera); } catch (error) { console.error("Render error:", error); isPaused = true; } }
        window.addEventListener('load', init);
    </script>
</body>
</html>